<!doctype html>
<html lang="us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content="Cyberlightning FI-WARE - IoT project, Author: Tomi Sarni">
    <meta name="viewport" content="width=device-width">
    <title>Cyberlightning FI-WARE</title>

    <link href="css/eggplant/jquery-ui-1.10.3.custom.css" rel="stylesheet">
    
	<script src="js/jquery-1.9.1.js"></script>
	<script src="js/jquery-ui-1.10.3.custom.js"></script>
	<script src="js/three.min.js"></script>
	<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
	
    <script type="text/javascript">
	 $(function() {
		 $( "#accordion" ).accordion();
		 });
	 $(function() {
		 var spinner = $( "#spinner" ).spinner();
		 });
	 $.widget("ui.formatSpinner", $.ui.spinner, {
		    options: {
		    },
		    _parse: function (value) {
		        if (typeof value === "string") {                
		            return this.options.values.indexOf(value);
		        }
		        return value;            
		    },
		    _format: function (value) {
		        //wrap around
		        if (value < 0) {
		            value = this.options.count-1;
		        }
		        if (value > this.options.count-1) {
		            value = 0;
		        }
		        var format = this.options.values[value];
		        return format;
		    },          
		});
	 
	   
	
	    

	</script>
	
	<style>
	body{
		font: 62.5% "Trebuchet MS", sans-serif;
		margin: 30px;
		background-color:#1F001F;
	}
    canvas{
    }
    
    #buttons div {
  		display: inline;
  		width:100%;
 
  	}
  	
	</style>
</head>



<body>
		<div align="left" style="width:100%;height:100px">
			<img alt="" src="assets/logo.png">	
		</div>
	
		<div style="width:100%;height:100%">
  			<div id="content_left" style="background-color:#D2CCD2;height:650px;width:49%;float:left;"></div>
  			<div style="background-color:#938F93;height:650px;width:0.3%;float:left;"></div>
  			<div style="background-color:#D2CCD2;height:650px;width:50.7%;float:left;">
				<div id="accordion"></div>
  			</div>
  			<div align="right" style="background-color:#4C334C;clear:both;color:white;font-size: 9">Copyright Â© 2013 Cyberlightning Ltd.</div>
 			<div id="buttons" style="width:100%;">
  				<button id="connect_button" onClick="WebSocketTest()">connect</button>
  				<input id="spinner-sensors" type="text" value=""/>
  				<form id="frm"><input id="command_input" type="text" placeholder="Command to be sent to sensor"></form>
				<button id="send_button" onClick="sendData()">Send</button>
  			</div>
  		</div>
		<div id="holder"></div> <!-- This needs to be removed, dummy layer for JSON data -->
	
	<script type="text/javascript">

	//var arrPaperTypes = ["Standard 80g", "Standard 100g", "Gloss 100g", "Gloss 120g"];
	var sensorTypes = [];

	$(function() {
	    $("#spinner-sensors").formatSpinner({
	        values: sensorTypes,
	        count: sensorTypes.length
	    });
	}); 
	
	var map;
	var lat;
	var lon;
	
	

	function sendData() {
		var input = frm.command_input.value;
// 		$.ajax({
// 	  	type: "POST",
// 	  	url: "http://dev.cyberlightning.com:44446/" + input,
// 	  	async: true,
// 	  	cache: false,
// 	  	timeout:50000,
// 	  	success: function(data){
// 	  		alert("success: "+data);
// 	  	}, 
// 	  	error: function(XMLHttpRequest, textStatus, errorThrown){
			
// 	  		alert("error: " + textStatus + " (" + errorThrown + ")");
// 	             setTimeout(
// 	                    sendData, 
// 	                    30000); 
// 	            }
// 	    });

		 ws.send(input);
	};
	
	//Global variables
	
	var WIDTH = $("#content_left").height();
	var HEIGHT = $("#content_left").width();
	

	// set some camera attributes
	var VIEW_ANGLE = 45,
	  ASPECT = WIDTH / HEIGHT,
	  NEAR = 0.1,
	  FAR = 10000;

	// get the DOM element to attach to
	// - assume we've got jQuery to hand
	var $container = $('#content_left');

	// create a WebGL renderer, camera
	// and a scene
	renderer = new THREE.WebGLRenderer( {antialias:true} );
	
	var ws; //websocket 
	var json;
	var sensors = [];
    var type;

	function setContent() {

        var alreadyExists = false;
		
		if (sensors != null) {
            for(var i =0;i<sensors.length;i++){
                if(sensors[i].device_properties.type == json.device_properties.type) {
                    alreadyExists = true;
                    break;
                }
            }
        }

        sensors.push(json);

		if (!alreadyExists) {
			
			if(json.device_properties.type == "TYPE_GPS") {
				lat = parseDouble(json.event_values[0]);
				lon = parseDouble(json.event_values[1]);
				type =  json.device_properties.type;
	            sensorTypes.push(json.device_properties.type);
				var active = $('#accordion').accordion('option', 'active');
				$('#accordion').append('<h3><a href="#" onclick="loadMap(event)">' + type + '</a></h3><div  id="map-canvas"></div>') 
				    .accordion('destroy').accordion({ active: active});	
				
				
				
			} else {
				type =  json.device_properties.type;
	            sensorTypes.push(json.device_properties.type);
				var active = $('#accordion').accordion('option', 'active');
				$('#accordion').append('<h3><a href="#" onclick="drawCharts(event)">' + type + '</a></h3><div>'+ parseContent(json) +'</div>')
				    .accordion('destroy').accordion({ active: active});	
			}
            
		}
	}

	function parseContent(data) {
        var content = "<b>Device Id:</b><i>" + data.device_id + "</i>   <b>Current Uptime:</b> <i>" + Math.round(eval(data.device_uptime)/60000000000)  + " minutes</i></br>";
        content += "<b>Sensor vendor: </b><i>" + data.device_properties.vendor + "</i>   <b>Power usage: </b><i>" + data.device_properties.power + " mA </i></br>";
        content += "<b>Latest recorded sensor event: </b><i>" + data.event_timestamp + "</i>";
        return content;
    }
	
	function loadMap(e) {
		  var mapOptions = {
		    zoom: 8,
		    center: new google.maps.LatLng(lat, lon),
		    mapTypeId: google.maps.MapTypeId.ROADMAP
		  };
		  map = new google.maps.Map(document.getElementById('map-canvas'),mapOptions);
		  google.maps.event.addDomListener(window, 'load', initialize);
	}
	
	function drawCharts(e) {
		
		var eventTarget = e.currentTarget.innerHTML; //works on both chrome and FF
		var cubeX = 20;
		var cubeZ = 20;
		var cubeY = 0;
		
		var tempSensorList = sensors;
		var xValues = [];
		
		var timeStamps = [];
		var minValue = 50000;
		var maxValue = 0;
		
		for (var i = 0 ; i < tempSensorList.length; i++) {
			if (tempSensorList[i].device_properties.type == eventTarget) {
				xValues.push(tempSensorList[i].event_values[0]);
				if (minValue > parseFloat(tempSensorList[i].event_values[0])) {
					minValue = parseFloat(tempSensorList[i].event_values[0]);
				}
				if (maxValue < parseFloat(tempSensorList[i].event_values[0])) {
					maxValue = parseFloat(tempSensorList[i].event_values[0]);
				}
			
				timeStamps.push(tempSensorList[i].event_timestamp)	
			}
		}
		
		if(eventTarget == "TYPE_LIGHT" || eventTarget =="TYPE_PRESSURE" || eventTarget == "TYPE_MAGNETIC_FIELD") { //TODO: implement more dynamic way to present data
            
			var standardized = 100/(maxValue - minValue);
			var camera =
				  new THREE.PerspectiveCamera(
				    VIEW_ANGLE,
				    ASPECT,
				    NEAR,
				    FAR);

			var scene = new THREE.Scene();
				
			scene.add(camera);
				
			// the camera starts at 0,0,0
			// so pull it back
			camera.position.z = 300;
			camera.position.y = 200;
			camera.position.x = 100;

			// start the renderer
			renderer.setSize(WIDTH, HEIGHT);

			// attach the render-supplied DOM element
			$container.append(renderer.domElement);

			// create a point light
			var pointLight = new THREE.PointLight(0xFFFFFF);

			// set its position
			pointLight.position.x = 10;
			pointLight.position.y = 50;
			pointLight.position.z = 130;

			// add to the scene
			scene.add(pointLight);
				
			var material = new THREE.LineBasicMaterial({color: 0x0000ff});
				
			var geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			geometry.vertices.push(new THREE.Vector3(0, 100, 0));
				
			var line = new THREE.Line(geometry, material);
			scene.add(line);
				
			var geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			geometry.vertices.push(new THREE.Vector3(0, 0, 100));
				
			var line = new THREE.Line(geometry, material);
			scene.add(line);
				
			var geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			geometry.vertices.push(new THREE.Vector3(100,0 , 0));
				
			var line = new THREE.Line(geometry, material);
			scene.add(line);
			camera.lookAt( scene.position );
				
			var j = 0;
			
			while(j < xValues.length && j < 5) {

				if (xValues.length > 1 ) {
					cubeY = (parseFloat(xValues[j]) - minValue) * standardized;
				} else {
					cubeY = parseFloat(xValues[j]) * standardized;
				}
				
				if (cubeY == 0) cubeY = 1;

				var geometry = new THREE.CubeGeometry( cubeX, cubeY, cubeZ );

        		for ( var i = 0; i < geometry.faces.length; i += 2 ) {
					var hex = Math.random() * 0xffffff;
        			geometry.faces[ i ].color.setHex( hex );
        			geometry.faces[ i + 1 ].color.setHex( hex );
        		}

        		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );
        		cube = new THREE.Mesh( geometry, material );
        		cube.position.y = cubeY/2;
        		cube.position.x = cubeX/2 + j*20; //20 pixels space between bars after first
        		cube.position.z = cubeZ/2;
        		scene.add( cube );
        	 
        		j++

			}
			
			var canvas1 = document.createElement('canvas');
    		var context1 = canvas1.getContext('2d');
    		context1.font = "14px Arial";
    		context1.fillStyle = "rgba(0,0,0,0.95)";
    		context1.fillText("Value range: " + parseFloat(minValue).toFixed(2) + " - " + parseFloat(maxValue).toFixed(2), 0, 50);
    		    
    		// canvas contents will be used for a texture
    		var texture1 = new THREE.Texture(canvas1)
    		texture1.needsUpdate = true;
    		      
    		    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
    		    material1.transparent = true;

    		    var mesh1 = new THREE.Mesh(
    		        new THREE.PlaneGeometry(canvas1.width, canvas1.height),
    		        material1
    		      );
    		mesh1.position.set(0,20,-300);
    		scene.add( mesh1 );
			renderer.render(scene, camera);
		} 
	}

	function WebSocketTest() {
       
		if ("WebSocket" in window) {
          
          //ws = new WebSocket("ws://127.0.0.1:44445");
          ws = new WebSocket("ws://dev.cyberlightning.com:44445");
          ws.onopen = function() {
             // Web Socket is connected, send data using send()
            //ws.send("Message to send");
             alert("Connected to the web server."); 	 
          };
          ws.onmessage = function (evt) {
        	document.getElementById("holder").innerHTML = evt.data;
            json = JSON.parse(document.getElementById("holder").innerHTML);
            document.getElementById("holder").innerHTML = "";
            setContent();
          };
          ws.onclose = function() {
             // websocket is closed.
             alert("Connection is closed...");
          };
       }
       else {
          // The browser doesn't support WebSocket
          alert("WebSocket NOT supported by your Browser!");
       }
     }
	
	
	 
	</script>
</body>
</html>
