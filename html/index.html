<!doctype html>
<html lang="us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content="Cyberlightning FI-WARE - IoT project, Author: Tomi Sarni">
    <meta name="viewport" content="width=device-width">
    <title>Cyberlightning FI-WARE</title>

    <link href="css/eggplant/jquery-ui-1.10.3.custom.css" rel="stylesheet">

	<script src="js/jquery-1.9.1.js"></script>
	<script src="js/jquery-ui-1.10.3.custom.js"></script>
	<script src="js/three.min.js"></script>
	<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
	
    <script type="text/javascript">
	 $(function() {
		 $( "#accordion" ).accordion();
		 });
	</script>
	
	<style>
	body{
		font: 62.5% "Trebuchet MS", sans-serif;
		margin: 30px;
		background-color:#1F001F;
	} #buttons div {
  		display: inline;
  		width:100%;
  	}.btn {
    display: inline-block;
    margin-right: 6px;
    }
	</style>
</head>

<body>
		<div align="left" style="width:100%;height:100px">
			<img alt="" src="assets/logo.png">	
		</div>
	    <div align="right" style="width:100%">
            <button id="connect_button" style="display: inline-block;" onClick="WebSocketTest()">connect</button>
            <form style="display: inline-block;" id="frm"><input id="command_input" type="text" placeholder="Command to be sent to sensor"></form>
			<button style="display: inline-block;" id="send_button" onClick="sendData()">Send</button></div>
		<div style="width:100%;height:100%">

  			<div id="content_left" style="background-color:#D2CCD2;height:650px;width:49%;float:left;"></div>
  			<div style="background-color:#938F93;height:650px;width:0.3%;float:left;"></div>
  			<div style="background-color:#D2CCD2;height:650px;width:50.7%;float:left;">
				<div id="accordion"></div>
  			</div>
  			<div align="right" style="background-color:#4C334C;clear:both;color:white;font-size: 9">Copyright Â© 2013 Cyberlightning Ltd.</div>
 			<div id="device_control" style="width:100%;"></div>
  		</div>
		<div id="holder">
		</div> <!-- This needs to be removed, dummy layer for JSON data -->
	
	<script type="text/javascript">
	
	//Global variables
	
	var WIDTH = $("#content_left").height();
	var HEIGHT = $("#content_left").width();
	

	// set some camera attributes
	var VIEW_ANGLE = 45,
	  ASPECT = WIDTH / HEIGHT,
	  NEAR = 0.1,
	  FAR = 10000;

	// get the DOM element to attach to
	// - assume we've got jQuery to hand
	var $container = $('#content_left');

	// create a WebGL renderer, camera
	// and a scene
	renderer = new THREE.WebGLRenderer( {antialias:true} );
	
	var ws; //websocket 
	var json;
    var type;
    var map;
	var lat;
	var lon;
    var entities = {};
    var selectedUUID;
    //var currentUuid;
    var listOfUUIDS;

    function createButton(currentUuid) {
        $("#device_control").append('<button style="display: inline-block;" onClick="changeDevice(event)">'+currentUuid+'</button>')
    }
    function changeDevice(e) {
        this.selectedUUID = e.currentTarget.innerHTML;
        updateContent(entities[selectedUUID]);
    }
	function setContent() {

		for (var baseUUID in json) {
		    if (json.hasOwnProperty(baseUUID)) {
		    	for (var deviceUUID in json[baseUUID]){
		    		var device = json[baseUUID];
		    		entities[deviceUUID] = device[deviceUUID];

                    if(listOfUUIDS == null) {
                        listOfUUIDS = [];
                        listOfUUIDS[0] = deviceUUID;
                        //currentUuid = deviceUUID;
                        createButton(deviceUUID);
                    } else {
                        var contains = true;
                        for(var k=0; k< listOfUUIDS.length; k++) {
                            if(listOfUUIDS[k] != deviceUUID) {
                             contains = false;
                            }
                        }
                        if(!contains){
                            listOfUUIDS.push(deviceUUID);
                            //currentUuid = deviceUUID;
                             createButton(deviceUUID);
                        }
                    }

		    	}
		        
		    }
		}

		for(var uuid in entities) {
            if(entities.hasOwnProperty(uuid)) {
                if (selectedUUID != null) {
                    if(selectedUUID == uuid) {
                        updateContent(entities[uuid]);
                    }
                } else {
                    selectedUUID = uuid;
                    addNewContent(entities[uuid]);
                }
            }
        }
	}

    function addNewContent(obj) {
        var sensors = obj.sensors;
        var attr = [];
        for (var i = 0; i < sensors.length; i++ ) {
            if(sensors[i].attributes.type != null){
                type = sensors[i].attributes.type;
                var active = $('#accordion').accordion('option', 'active');
                    if(type == "gps"){
                        lat = parseFloat(json.event_values[0]);
				        lon = parseFloat(json.event_values[1]);
				        type =  json.device_properties.type;
	                    sensorTypes.push(json.device_properties.type);
				        $('#accordion').accordion({heightStyle: 'content'});
				        $('#accordion').append('<h3><a href="#" onclick="loadMap(event)">' + type + '</a></h3><div id="map-canvas" style="height:300px"></div>').accordion('destroy').accordion({ active: active});
                    }  else {
		                $('#accordion').append('<h3><a href="#" onclick="drawCharts(event)">' + type + '</a></h3><div>'+ parseContent(sensors[i],obj.attributes.location) +'</div>').accordion('destroy').accordion({ active: active});
                    }

            }
        }
    }

    function parseContent(obj,loc) {
        var content = "<b>Device Id: </b><i>" + selectedUUID + "</i>   <b>Latest Event: </b><i>" + (new Date()).toString() + "</i></br>";
        if(loc != null) content += "<b>Location: </b>[" +loc + "] ";
        content += "<b>Sensor value: </b>";
            for(var i = 0; i < obj.value.length; i++) {
                if (obj.value[i].primitive = "3DPoint") {
                    content += " [";
                    for (var j = 0; j < obj.value[i].values.length; j++) {
                     if (j < 2) content += obj.value[i].values[j] + ",";
                     else content += obj.value[i].values[j];
                    }
                    content += "] (" + obj.values[i].unit + ") ";
                } else {
                    content += obj.value[i].values + " " + obj.value[i].unit + ", ";
                }

            }
        return content;
    }

    function updateContent(obj) {
        var accordion = document.getElementById('accordion');
        while(accordion.hasChildNodes()) {
            accordion.removeChild(accordion.lastChild);
        }
        addNewContent(obj);
    }
	
	function loadMap(e) {
		  var mapOptions = {
		    zoom: 8,
		    center: new google.maps.LatLng(lat, lon),
		    mapTypeId: google.maps.MapTypeId.ROADMAP
		  };
		  map = new google.maps.Map(document.getElementById('map-canvas'),mapOptions);
		  google.maps.event.addDomListener(window, 'load', initialize);
	}
	
	function drawCharts(e) {
		
		var eventTarget = e.currentTarget.innerHTML; //works on both chrome and FF
		var cubeX = 20;
		var cubeZ = 20;
		var cubeY = 0;
		
		var tempSensorList = entities[selectedUUID].sensors;
		var xValues = [];
		

        var valueList = [];
		var minValue;
		var maxValue;
        var is3DPoint = false;
        var threeDPointValues = [];

        var camera = new THREE.PerspectiveCamera(
				    VIEW_ANGLE,
				    ASPECT,
				    NEAR,
				    FAR);

		var scene = new THREE.Scene();

		scene.add(camera);

			// the camera starts at 0,0,0
			// so pull it back
			camera.position.z = 300;
			camera.position.y = 200;
			camera.position.x = 100;

			// start the renderer
			renderer.setSize(WIDTH, HEIGHT);

			// attach the render-supplied DOM element
			$container.append(renderer.domElement);

			// create a point light
			var pointLight = new THREE.PointLight(0xFFFFFF);

			// set its position
			pointLight.position.x = 10;
			pointLight.position.y = 50;
			pointLight.position.z = 130;

			// add to the scene
			scene.add(pointLight);



		for (var i = 0 ; i < tempSensorList.length; i++) {
			if (tempSensorList[i].attributes.type == eventTarget) {
                valueList = tempSensorList[i].value;

                for(var j = 0; j < valueList.length; j++) {
                    if(valueList[j].primitive == "3DPoint") {
                        is3DPoint = true;
                        for (var k=0; k < valueList[j].values.length; k++) {
                            threeDPointValues.push(valueList[j].values[k]);
                        }
                    } else {
                        xValues.push(valueList[j].values);
                        if (minValue > parseFloat(valueList[j].values) || minValue == null) {
					        minValue = parseFloat(valueList[j].values);
				        } if (maxValue < parseFloat(valueList[j].values) || maxValue == null) {
					        maxValue = parseFloat(valueList[j].values);
				        }
                    }
                }
			}
		}


		if (is3DPoint){

        var material = new THREE.LineBasicMaterial({color: 0x0000ff});

		    var geometry = new THREE.Geometry();
		    geometry.vertices.push(new THREE.Vector3(0, 50, 0));
		    geometry.vertices.push(new THREE.Vector3(0, threeDPointValues[1] + 50, 0));

			var line = new THREE.Line(geometry, material);
			scene.add(line);

            material = new THREE.LineBasicMaterial({color: 0x00ff00});
            var geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(0, 50, 0));
			geometry.vertices.push(new THREE.Vector3(0, 50, threeDPointValues[2] ));

			var line = new THREE.Line(geometry, material);
		    scene.add(line);

			material = new THREE.LineBasicMaterial({color: 0xff0000});
			var geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 50, 0));
			geometry.vertices.push(new THREE.Vector3(threeDPointValues[0],50, 0));

			var line = new THREE.Line(geometry, material);
			scene.add(line);
			camera.lookAt( scene.position );

        } else {
            var material = new THREE.LineBasicMaterial({color: 0x0000ff});

			var geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			geometry.vertices.push(new THREE.Vector3(0, 100, 0));

			var line = new THREE.Line(geometry, material);
			scene.add(line);

			var geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			geometry.vertices.push(new THREE.Vector3(0, 0, 100));

			var line = new THREE.Line(geometry, material);
			scene.add(line);

			var geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			geometry.vertices.push(new THREE.Vector3(100,0 , 0));

			var line = new THREE.Line(geometry, material);
			scene.add(line);
			camera.lookAt( scene.position );

			var j = 0;

			while(j < xValues.length && j < 5) {

				    if(minValue == maxValue) {
                         cubeY = 50;
                    } else {
                        cubeY = (parseFloat(xValues[j])/ maxValue) * 100;
                    }

				    var geometry = new THREE.CubeGeometry( cubeX, cubeY, cubeZ );

        		    for ( var i = 0; i < geometry.faces.length; i += 2 ) {
					    var hex = Math.random() * 0xffffff;
        			    geometry.faces[ i ].color.setHex( hex );
        			    geometry.faces[ i + 1 ].color.setHex( hex );
        		    }

        		    var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );
        		    cube = new THREE.Mesh( geometry, material );
        		    cube.position.y = cubeY/2;
        		    cube.position.x = cubeX/2 + j*20; //20 pixels space between bars after first
        		    cube.position.z = cubeZ/2;
        		    scene.add( cube );

        		    j++
			    }
            var canvas1 = document.createElement('canvas');
    		var context1 = canvas1.getContext('2d');
    		context1.font = "14px Arial";
    		context1.fillStyle = "rgba(0,0,0,0.95)";
    		context1.fillText("Value range: " + parseFloat(minValue).toFixed(2) + " - " + parseFloat(maxValue).toFixed(2), 0, 50);

    		// canvas contents will be used for a texture
    		var texture1 = new THREE.Texture(canvas1)
    		texture1.needsUpdate = true;

    		    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
    		    material1.transparent = true;

    		    var mesh1 = new THREE.Mesh(
    		        new THREE.PlaneGeometry(canvas1.width, canvas1.height),
    		        material1
    		      );
    		mesh1.position.set(0,20,-300);
            scene.add( mesh1 );
            }

			renderer.render(scene, camera);

	}

    function sendData() {
		var input = frm.command_input.value;
        ws.send(input);
	};


	function WebSocketTest() {
       
		if ("WebSocket" in window) {
          // Check if connection is already open before creating new so we do not spam server with duplicate connections.
          if (ws != null && ws.readyState === ws.OPEN)
          {
          	alert("Websocket connection is already established!");
          	return;
          }
          else
          	{
				// Use localhost IP for websocket
				ws = new WebSocket("ws://127.0.0.1:44445");

				// Use dev.cyberlightning.com IP for websocket	
				//ws = new WebSocket("ws://dev.cyberlightning.com:44445");	
          	}
          ws.onopen = function() {
             // Web Socket is connected, send data using send()
            //ws.send("Message to send");
             alert("Connected to the web server."); 	 
          };
          ws.onmessage = function (evt) {
        	document.getElementById("holder").innerHTML = evt.data;
            json = JSON.parse(document.getElementById("holder").innerHTML);
            document.getElementById("holder").innerHTML = "";
            setContent();
          };
          ws.onclose = function() {
             // websocket is closed.
             ws = null;
             alert("Connection is closed...");
          };
       }
       else {
          // The browser doesn't support WebSocket
          alert("WebSocket NOT supported by your Browser!");
       }
     }	
	 
	</script>
</body>
</html>
